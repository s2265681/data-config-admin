const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class FolderManager {
  constructor() {
    this.foldersConfigPath = path.join(process.cwd(), 'config', 'folders.json');
    this.foldersConfig = this.loadFoldersConfig();
    // Âú®LambdaÁéØÂ¢É‰∏≠‰ΩøÁî®/tmpÁõÆÂΩï‰Ωú‰∏∫ÂèØÂÜôÁõÆÂΩï
    this.basePath = process.env.AWS_LAMBDA_FUNCTION_NAME ? '/tmp' : process.cwd();
  }

  loadFoldersConfig() {
    try {
      const configContent = fs.readFileSync(this.foldersConfigPath, 'utf8');
      return JSON.parse(configContent);
    } catch (error) {
      console.error('Âä†ËΩΩÊñá‰ª∂Â§πÈÖçÁΩÆÂ§±Ë¥•:', error);
      throw error;
    }
  }

  // Ëé∑ÂèñÊâÄÊúâÊñá‰ª∂Â§πÈÖçÁΩÆ
  getFolders() {
    return this.foldersConfig.folders;
  }

  // Ê†πÊçÆÊñá‰ª∂Â§πÂêçÁß∞Ëé∑ÂèñÈÖçÁΩÆ
  getFolderByName(folderName) {
    return this.foldersConfig.folders.find(folder => folder.name === folderName);
  }

  // Ëé∑ÂèñÁéØÂ¢ÉÈÖçÁΩÆ
  getEnvironments() {
    return this.foldersConfig.environments;
  }

  // Ëé∑ÂèñÁõëÊéßÈÖçÁΩÆ
  getMonitoringConfig() {
    return this.foldersConfig.monitoring;
  }

  // ÁîüÊàêÂÆåÊï¥ÁöÑÊñá‰ª∂ÂàóË°®ÔºàÂÖºÂÆπÊóßÁöÑfiles.jsonÊ†ºÂºèÔºâ
  generateFilesList() {
    const files = [];
    
    this.foldersConfig.folders.forEach(folder => {
      folder.files.forEach(file => {
        const fileName = file.name;
        const localPath = path.join(folder.local_path, fileName);
        
        files.push({
          name: localPath,
          description: file.description,
          folder: folder.name,
          s3_prefix: folder.s3_prefix,
          staging_path: `${folder.s3_prefix}/staging/${fileName}`,
          production_path: `${folder.s3_prefix}/production/${fileName}`
        });
      });
    });
    
    return files;
  }

  // Ê£ÄÊü•Êñá‰ª∂Â§πÊòØÂê¶Â≠òÂú®
  folderExists(folderName) {
    const folder = this.getFolderByName(folderName);
    if (!folder) {
      return false;
    }
    const folderPath = path.join(process.cwd(), folder.local_path);
    return fs.existsSync(folderPath);
  }

  // ÂàõÂª∫Êñá‰ª∂Â§πÁªìÊûÑ
  createFolderStructure() {
    console.log('üìÅ ÂàõÂª∫Êñá‰ª∂Â§πÁªìÊûÑ...');
    
    this.foldersConfig.folders.forEach(folder => {
      const folderPath = path.join(process.cwd(), folder.local_path);
      
      if (!fs.existsSync(folderPath)) {
        fs.mkdirSync(folderPath, { recursive: true });
        console.log(`  ‚úÖ ÂàõÂª∫Êñá‰ª∂Â§π: ${folder.local_path}`);
      } else {
        console.log(`  ‚ÑπÔ∏è  Êñá‰ª∂Â§πÂ∑≤Â≠òÂú®: ${folder.local_path}`);
      }
    });
    
    console.log('üìÅ Êñá‰ª∂Â§πÁªìÊûÑÂàõÂª∫ÂÆåÊàêÔºÅ');
  }

  // ÁßªÂä®Áé∞ÊúâÊñá‰ª∂Âà∞Êñ∞ÁöÑÊñá‰ª∂Â§πÁªìÊûÑ
  migrateFiles() {
    console.log('üîÑ ÂºÄÂßãËøÅÁßªÊñá‰ª∂Âà∞Êñ∞ÁöÑÊñá‰ª∂Â§πÁªìÊûÑ...');
    
    const migrationMap = {
      'app-config/test.json': 'app-config/config/test.json',
      'app-config/test2.json': 'app-config/config2/test2.json', 
      'app-config/test3.json': 'app-config/config2/test3.json',
      'app-config/test4.json': 'app-config/config3/test4.json'
    };
    
    Object.entries(migrationMap).forEach(([source, target]) => {
      const sourcePath = path.join(process.cwd(), source);
      const targetPath = path.join(process.cwd(), target);
      
      if (fs.existsSync(sourcePath)) {
        // Á°Æ‰øùÁõÆÊ†áÁõÆÂΩïÂ≠òÂú®
        const targetDir = path.dirname(targetPath);
        if (!fs.existsSync(targetDir)) {
          fs.mkdirSync(targetDir, { recursive: true });
        }
        
        // ÁßªÂä®Êñá‰ª∂
        fs.renameSync(sourcePath, targetPath);
        console.log(`  ‚úÖ ËøÅÁßª: ${source} ‚Üí ${target}`);
      } else {
        console.log(`  ‚ö†Ô∏è  Ê∫êÊñá‰ª∂‰∏çÂ≠òÂú®: ${source}`);
      }
    });
    
    console.log('üîÑ Êñá‰ª∂ËøÅÁßªÂÆåÊàêÔºÅ');
  }

  // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
  fileExists(folderName, fileName, environment) {
    const folder = this.getFolderByName(folderName);
    if (!folder) {
      return false;
    }
    let filePath;
    if (environment === 'staging' && folder.local_path_staging) {
      filePath = path.join(this.basePath, folder.local_path_staging, fileName);
    } else if (environment === 'production' && folder.local_path_production) {
      filePath = path.join(this.basePath, folder.local_path_production, fileName);
    } else if (folder.local_path) {
      filePath = path.join(this.basePath, folder.local_path, environment, fileName);
    } else {
      return false;
    }
    return fs.existsSync(filePath);
  }

  // ËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ
  readFile(folderName, fileName, environment) {
    const folder = this.getFolderByName(folderName);
    if (!folder) {
      throw new Error(`Êñá‰ª∂Â§π ${folderName} Êú™Âú®ÈÖçÁΩÆ‰∏≠ÊâæÂà∞`);
    }
    let filePath;
    if (environment === 'staging' && folder.local_path_staging) {
      filePath = path.join(this.basePath, folder.local_path_staging, fileName);
    } else if (environment === 'production' && folder.local_path_production) {
      filePath = path.join(this.basePath, folder.local_path_production, fileName);
    } else if (folder.local_path) {
      filePath = path.join(this.basePath, folder.local_path, environment, fileName);
    } else {
      throw new Error(`Êñá‰ª∂Â§π ${folderName} Êú™ÈÖçÁΩÆÊú¨Âú∞Ë∑ØÂæÑ`);
    }
    if (!this.fileExists(folderName, fileName, environment)) {
      throw new Error(`Êñá‰ª∂ ${fileName} Âú®Êñá‰ª∂Â§π ${folderName} ‰∏≠‰∏çÂ≠òÂú®`);
    }
    return fs.readFileSync(filePath, 'utf8');
  }

  // ÂÜôÂÖ•Êñá‰ª∂ÂÜÖÂÆπ
  writeFile(folderName, fileName, content, environment) {
    const folder = this.getFolderByName(folderName);
    if (!folder) {
      throw new Error(`Êñá‰ª∂Â§π ${folderName} Êú™Âú®ÈÖçÁΩÆ‰∏≠ÊâæÂà∞`);
    }
    let filePath;
    if (environment === 'staging' && folder.local_path_staging) {
      filePath = path.join(this.basePath, folder.local_path_staging, fileName);
    } else if (environment === 'production' && folder.local_path_production) {
      filePath = path.join(this.basePath, folder.local_path_production, fileName);
    } else if (folder.local_path) {
      filePath = path.join(this.basePath, folder.local_path, environment, fileName);
    } else {
      throw new Error(`Êñá‰ª∂Â§π ${folderName} Êú™ÈÖçÁΩÆÊú¨Âú∞Ë∑ØÂæÑ`);
    }
    // Á°Æ‰øùÁõÆÂΩïÂ≠òÂú®
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(filePath, content, 'utf8');
  }

  // ËÆ°ÁÆóÊñá‰ª∂ÂìàÂ∏å
  getFileHash(folderName, fileName, environment) {
    const content = this.readFile(folderName, fileName, environment);
    return crypto.createHash('sha256').update(content).digest('hex');
  }

  // Ëé∑ÂèñÊñá‰ª∂‰øÆÊîπÊó∂Èó¥
  getFileModifiedTime(folderName, fileName, environment) {
    const folder = this.getFolderByName(folderName);
    if (!folder) {
      throw new Error(`Êñá‰ª∂Â§π ${folderName} Êú™Âú®ÈÖçÁΩÆ‰∏≠ÊâæÂà∞`);
    }
    let filePath;
    if (environment === 'staging' && folder.local_path_staging) {
      filePath = path.join(process.cwd(), folder.local_path_staging, fileName);
    } else if (environment === 'production' && folder.local_path_production) {
      filePath = path.join(process.cwd(), folder.local_path_production, fileName);
    } else if (folder.local_path) {
      filePath = path.join(process.cwd(), folder.local_path, environment, fileName);
    } else {
      throw new Error(`Êñá‰ª∂Â§π ${folderName} Êú™ÈÖçÁΩÆÊú¨Âú∞Ë∑ØÂæÑ`);
    }
    const stats = fs.statSync(filePath);
    return stats.mtime;
  }

  // Ëé∑ÂèñÊâÄÊúâÊñá‰ª∂ÁöÑÁä∂ÊÄÅ
  getAllFilesStatus() {
    const status = {};
    
    this.foldersConfig.folders.forEach(folder => {
      status[folder.name] = {};
      folder.files.forEach(file => {
        const fileName = file.name;
        status[folder.name][fileName] = {
          exists: this.fileExists(folder.name, fileName),
          modified: this.fileExists(folder.name, fileName) ? 
            this.getFileModifiedTime(folder.name, fileName) : null,
          hash: this.fileExists(folder.name, fileName) ? 
            this.getFileHash(folder.name, fileName) : null
        };
      });
    });
    
    return status;
  }

  // Ëé∑ÂèñÂèòÊõ¥ÁöÑÊñá‰ª∂ÂàóË°®
  getChangedFiles(previousHashes = {}) {
    const changedFiles = [];
    
    this.foldersConfig.folders.forEach(folder => {
      folder.files.forEach(file => {
        const fileName = file.name;
        if (this.fileExists(folder.name, fileName)) {
          const currentHash = this.getFileHash(folder.name, fileName);
          const previousHash = previousHashes[folder.name]?.[fileName];
          
          if (!previousHash || currentHash !== previousHash) {
            changedFiles.push({
              folder: folder.name,
              name: fileName,
              localPath: path.join(folder.local_path, fileName),
              s3Path: `${folder.s3_prefix}/staging/${fileName}`,
              hash: currentHash,
              description: file.description
            });
          }
        }
      });
    });
    
    return changedFiles;
  }

  // È™åËØÅJSONÊ†ºÂºè
  validateJsonFile(folderName, fileName) {
    try {
      const content = this.readFile(folderName, fileName);
      JSON.parse(content);
      return true;
    } catch (error) {
      console.error(`Êñá‰ª∂ ${fileName} Âú®Êñá‰ª∂Â§π ${folderName} ‰∏≠JSONÊ†ºÂºèÊó†Êïà:`, error);
      return false;
    }
  }

  // Ê†ºÂºèÂåñJSONÊñá‰ª∂
  formatJsonFile(folderName, fileName) {
    try {
      const content = this.readFile(folderName, fileName);
      const parsed = JSON.parse(content);
      const formatted = JSON.stringify(parsed, null, 2);
      this.writeFile(folderName, fileName, formatted);
      return true;
    } catch (error) {
      console.error(`Ê†ºÂºèÂåñÊñá‰ª∂ ${fileName} Âú®Êñá‰ª∂Â§π ${folderName} ‰∏≠Â§±Ë¥•:`, error);
      return false;
    }
  }

  // Ê∑ªÂä†Êñ∞Êñá‰ª∂Âà∞Êñá‰ª∂Â§π
  addFileToFolder(folderName, fileName, description = '') {
    const folder = this.getFolderByName(folderName);
    if (!folder) {
      throw new Error(`Êñá‰ª∂Â§π ${folderName} Êú™Âú®ÈÖçÁΩÆ‰∏≠ÊâæÂà∞`);
    }
    
    // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤Â≠òÂú®
    const existingFile = folder.files.find(file => file.name === fileName);
    if (existingFile) {
      throw new Error(`Êñá‰ª∂ ${fileName} Âú®Êñá‰ª∂Â§π ${folderName} ‰∏≠Â∑≤Â≠òÂú®`);
    }
    
    // Ê∑ªÂä†Êñá‰ª∂ÈÖçÁΩÆ
    folder.files.push({
      name: fileName,
      description: description
    });
    
    // ‰øùÂ≠òÈÖçÁΩÆ
    this.saveFoldersConfig();
    
    console.log(`‚úÖ Â∑≤Ê∑ªÂä†Êñá‰ª∂ ${fileName} Âà∞Êñá‰ª∂Â§π ${folderName}`);
  }

  // Ê∑ªÂä†Êñ∞Êñá‰ª∂Â§π
  addFolder(folderName, description, s3Prefix) {
    // Ê£ÄÊü•Êñá‰ª∂Â§πÊòØÂê¶Â∑≤Â≠òÂú®
    const existingFolder = this.getFolderByName(folderName);
    if (existingFolder) {
      throw new Error(`Êñá‰ª∂Â§π ${folderName} Â∑≤Â≠òÂú®`);
    }
    
    // Ê∑ªÂä†Êñá‰ª∂Â§πÈÖçÁΩÆ
    this.foldersConfig.folders.push({
      name: folderName,
      description: description,
      local_path: `app-config/${folderName}`,
      s3_prefix: s3Prefix,
      files: []
    });
    
    // ‰øùÂ≠òÈÖçÁΩÆ
    this.saveFoldersConfig();
    
    console.log(`‚úÖ Â∑≤Ê∑ªÂä†Êñá‰ª∂Â§π ${folderName}`);
  }

  // ‰øùÂ≠òÊñá‰ª∂Â§πÈÖçÁΩÆ
  saveFoldersConfig() {
    const configContent = JSON.stringify(this.foldersConfig, null, 2);
    fs.writeFileSync(this.foldersConfigPath, configContent, 'utf8');
  }

  // È™åËØÅÊñá‰ª∂Â§πÈÖçÁΩÆ
  validateFoldersConfig() {
    const errors = [];
    
    // Ê£ÄÊü•Êñá‰ª∂Â§πÂêçÁß∞ÂîØ‰∏ÄÊÄß
    const folderNames = this.foldersConfig.folders.map(f => f.name);
    const duplicateNames = folderNames.filter((name, index) => folderNames.indexOf(name) !== index);
    if (duplicateNames.length > 0) {
      errors.push(`ÈáçÂ§çÁöÑÊñá‰ª∂Â§πÂêçÁß∞: ${duplicateNames.join(', ')}`);
    }
    
    // Ê£ÄÊü•S3ÂâçÁºÄÂîØ‰∏ÄÊÄßÔºàÊîØÊåÅÊñ∞ÁöÑstagingÂíåproductionÂâçÁºÄÔºâ
    const s3Prefixes = [];
    this.foldersConfig.folders.forEach(folder => {
      if (folder.s3_prefix_staging) {
        s3Prefixes.push(folder.s3_prefix_staging);
      }
      if (folder.s3_prefix_production) {
        s3Prefixes.push(folder.s3_prefix_production);
      }
      // ÂÖºÂÆπÊóßÁöÑs3_prefixÂ≠óÊÆµ
      if (folder.s3_prefix) {
        s3Prefixes.push(folder.s3_prefix);
      }
    });
    
    const duplicatePrefixes = s3Prefixes.filter((prefix, index) => s3Prefixes.indexOf(prefix) !== index);
    if (duplicatePrefixes.length > 0) {
      errors.push(`ÈáçÂ§çÁöÑS3ÂâçÁºÄ: ${duplicatePrefixes.join(', ')}`);
    }
    
    // Ê£ÄÊü•Êñá‰ª∂ÂêçÁß∞ÂîØ‰∏ÄÊÄß
    const allFileNames = [];
    this.foldersConfig.folders.forEach(folder => {
      folder.files.forEach(file => {
        allFileNames.push(`${folder.name}/${file.name}`);
      });
    });
    const duplicateFileNames = allFileNames.filter((name, index) => allFileNames.indexOf(name) !== index);
    if (duplicateFileNames.length > 0) {
      errors.push(`ÈáçÂ§çÁöÑÊñá‰ª∂ÂêçÁß∞: ${duplicateFileNames.join(', ')}`);
    }
    
    return {
      isValid: errors.length === 0,
      errors: errors
    };
  }

  // ÁîüÊàêÊñá‰ª∂Â§πÁªìÊûÑÊä•Âëä
  generateFolderReport() {
    console.log('üìä Êñá‰ª∂Â§πÁªìÊûÑÊä•Âëä:');
    console.log('==================');
    
    this.foldersConfig.folders.forEach(folder => {
      console.log(`\nüìÅ ${folder.name} (${folder.description})`);
      console.log(`   Êú¨Âú∞Ë∑ØÂæÑ: ${folder.local_path}`);
      console.log(`   S3ÂâçÁºÄ: ${folder.s3_prefix}`);
      console.log(`   Êñá‰ª∂Êï∞Èáè: ${folder.files.length}`);
      
      if (folder.files.length > 0) {
        console.log('   Êñá‰ª∂ÂàóË°®:');
        folder.files.forEach(file => {
          const exists = this.fileExists(folder.name, file.name);
          console.log(`     ${exists ? '‚úÖ' : '‚ùå'} ${file.name} - ${file.description}`);
        });
      }
    });
    
    // È™åËØÅÈÖçÁΩÆ
    const validation = this.validateFoldersConfig();
    if (!validation.isValid) {
      console.log('\n‚ö†Ô∏è  ÈÖçÁΩÆÈ™åËØÅÈîôËØØ:');
      validation.errors.forEach(error => {
        console.log(`   - ${error}`);
      });
    } else {
      console.log('\n‚úÖ ÈÖçÁΩÆÈ™åËØÅÈÄöËøá');
    }
  }
}

module.exports = FolderManager; 